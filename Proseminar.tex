%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Author Robert Jeutter
% 
% to compile and run:
%    pdflatex Proseminar.tex
%    bibtex Proseminar
%    biber Proseminar
%    makeglossaries Proseminar
%    pdflatex Proseminar.tex
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[a4paper, 11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}
\usepackage{lmodern}
\usepackage{hyphenat}
\usepackage[babel,german=quotes]{csquotes}
\usepackage[left=1cm,top=1cm,right=1cm]{geometry}
\usepackage{amsmath,amsthm,amsfonts,amssymb}
\usepackage{color,graphicx,overpic,multirow}
\usepackage[dvipsnames]{xcolor}
\usepackage{pdflscape}
\usepackage{verbatim}
\usepackage{mdwlist} %less space for lists
\usepackage{gensymb} %degree symbol
\usepackage[hidelinks,pdfencoding=auto]{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
    pdftitle={Proseminar Objektposenschätzung}
    }
\usepackage{multicol}
%\setlength{\columnseprule}{1pt}
%\setlength{\columnsep}{1cm}
\setlength{\parskip}{0pt}
\setlength{\parindent}{0pt}

\usepackage[style=alphabetic]{biblatex}
\setlength{\bibitemsep}{1em} 
\bibliography{Proseminar}

\usepackage{glossaries}
\setglossarystyle{list} 
\makeglossaries
\newglossaryentry{knn}{
    name={KNN},
    description={Die Dynamik dieses Netzes gibt zu Beginn eine feste Architektur eines einschichtigen Netzes n-m vor. Das bedeutet, dass das Netz aus n Eingangsneuronen besteht, von denen jedes ein Eingang für alle m Ausgangsneuronen ist.}
}
\newglossaryentry{dnn}{
    name={DNN},
    description={Deep Neural Network: Ein tiefes neuronales Netz kann als gestapeltes neuronales Netz betrachtet werden, d.h. als Netz, das aus mehreren Schichten besteht.}
}
\newglossaryentry{cnn}{
    name={CNN},
    description={Convolutional Neural Network: Besitzt pro Convolutional Layer mehrere Filterkerne, sodass Schichten an Feature Maps entstehen, die jeweils die gleiche Eingabe bekommen, jedoch aufgrund unterschiedlicher Gewichtsmatrizen unterschiedliche Features extrahieren.}
}
\newglossaryentry{rnn}{
    name={RNN},
    description={Ein rekurrentes neuronales Netz ist eine Klasse von künstlichen neuronalen Netzen, bei denen die Verbindungen zwischen den Knoten einen gerichteten Graphen entlang einer zeitlichen Abfolge bilden. Dadurch können sie ein zeitlich dynamisches Verhalten zeigen.}
}
\newglossaryentry{gnn}{
    name={GNN},
    description={Graph Neural Network: ist eine Art von neuronalem Netz, das direkt auf der Struktur eines Graphen arbeitet. Eine typische Anwendung von GNN ist die Knotenklassifizierung. Im Wesentlichen ist jeder Knoten im Graphen mit einem Label verbunden, und wir wollen das Label der Knoten ohne Ground-Truth vorhersagen.}
}
\newglossaryentry{quaternion}{
    name={Quaternion-Darstellung},
    description={Darstellung $V$ einer Gruppe $G$, die einen $G$-invarianten Homomorphismus $J:V\rightarrow V$ besitzt, der antilinear ist und $J^2=-Id$ erfüllt.}
    }
\newglossaryentry{NOCS}{
    name={NOCS},
    description={Der Datensatz enthält 6 Objektkategorien: Flasche, Schüssel, Kamera, Dose, Laptop und Becher. Drei von diesen sind Kategorien mit symmetrischen Achsen.}
    }
\newglossaryentry{ShapeNetCore}{
    name={ShapeNetCore},
    description={ShapeNetCore ist eine Teilmenge des vollständigen ShapeNet-Datensatzes mit einzelnen sauberen 3D-Modellen und manuell verifizierten Kategorie- und Ausrichtungsannotationen. Er umfasst 55 gängige Objektkategorien mit etwa 51.300 einzigartigen 3D-Modellen. Die 12 Objektkategorien von PASCAL 3D+, einem beliebten 3D-Benchmark-Datensatz für Computer Vision, werden alle von ShapeNetCore abgedeckt.}
}
\newglossaryentry{YCBInEOAT}{
    name={YCBInEOAT},
    description={Dieser Datensatz hilft, die Effektivität der 6D-Positionsverfolgung während der Robotermanipulation zu überprüfen. Er enthält 9 Videosequenzen, die von einer statischen RGB-D-Kamera aufgenommen wurden, während die Objekte dynamisch manipuliert werden. Die Videos beinhalten 5 YCB Objekte: Glas, Dose, Zuckerbox, Bleichereiniger und Keksbox.}
}
\newglossaryentry{Linemod}{
    name={LINEMOD},
    description={LINEMOD ist ein RGB+D-Datensatz, der sich zu einem De-facto-Standard-Benchmark für 6D-Positionsschätzungen entwickelt hat. Der Datensatz enthält schlecht texturierte Objekte in einer unübersichtlichen Szene. 15 texturlose Haushaltsgegenstände mit Farbe, Form und Größe. Jedem Objekt ist ein Testbild zugeordnet, das eine kommentierte Objektinstanz mit erheblicher Unordnung, aber nur leichter Verdeckung zeigt.}
}
\newglossaryentry{Occlusion}{
    name={LM-Occlusion},
    description={Bietet zusätzliche Ground-Truth-Annotationen für alle modellierten Objekte in einer der Testgruppen von LIMEMOD. Dies führt anspruchsvolle Testfälle mit verschiedenen Verdeckungsgraden ein. Die Trainingsbilder sind die gleichen wie die für LIMEMOD.}
}
\newglossaryentry{mscoco}{
    name={MS-COCO},
    description={Microsoft Common Objects in Context ist ein groß angelegter Datensatz für Objekterkennung, Segmentierung, Key-Point-Erkennung und Beschriftung. Der Datensatz besteht aus 328K Bildern.}
}
\newglossaryentry{ycb}{
    name={YCB-Video},
    description={80 Videos zum Training mit 2.949 Schlüsselbildern, die aus den restlichen 12 Testvideos extrahiert wurden.}
}
\newglossaryentry{stanford}{
    name={Stanford 3D Scanning Repository},
    description={vier Datensätze Hase, Armadillo, Drache und Buddha als Punktwolke\cite{StanfordScanning}}
}
\newglossaryentry{bot}{
    name={Bayesian Object Tracking},
    description={37 aufgezeichnete Sequenzen von Tiefenbildern. Jede Sequenz ist ca. zwei Minuten lang und zeigt eines von sechs Objekten mit und ohne Teilverdeckung, die mit unterschiedlichen Geschwindigkeiten bewegt werden. Um die Verfolgungsleistung bei verschiedenen Geschwindigkeiten zu bewerten, enthält der Datensatz Sequenzen mit drei Geschwindigkeitskategorien. Der Abstand zwischen Kamera und Objekt liegt zwischen 0,8 m und 1,1 m. \cite{bot}}
}
\newglossaryentry{55cm}{
    name={5\textdegree 5cm},
    description={Prozentsatz der Schätzungen mit einem Orientierungsfehler $<5$\textdegree und einem Translationsfehler $< 5cm$ - je höher, desto besser}
}
\newglossaryentry{IoU25}{
    name={IoU25},
    description={(Intersection over Union) Prozentualer Anteil der Fälle, in denen die Überschneidung von Vorhersage und 3D Bounding Box größer ist als 25\% ihrer Vereinigung - je höher, desto besser
    besser}
}
\newglossaryentry{6dpose}{
    name={6D Pose},
    description={Die 6D-Positionsmetrik berechnet den durchschnittlichen Abstand zwischen den 3D-Modellpunkten, die mit Hilfe der der geschätzten Pose und der Grundwahrheits-Pose. Für symmetrische Objekte verwenden wir den Abstand der geschlossenen Punkte für die Berechnung des durchschnittlichen Abstands. Eine geschätzte Pose ist korrekt, wenn der durchschnittliche Abstand innerhalb von 10\% des 3D-Modelldurchmessers liegt.}
}
\newglossaryentry{2dproj}{
    name={2D Projection},
    description={Die 2D-Projektionsmetrik berechnet den durchschnittlichen Abstand der 3D-Modellpunkte die auf das Bild projiziert werden, unter Verwendung der geschätzten Pose und der Grundwahrheits-Pose. Eine geschätzte Pose ist korrekt, wenn der durchschnittliche Abstand kleiner als 5 Pixel ist.}
}
\newglossaryentry{Rerr}{
    name={R\_err},%R_{err}
    description={mittlerer Orientierungsfehler in Grad - je geringer desto besser}
}
\newglossaryentry{Terr}{
    name={T\_err},%T_{err}
    description={mittlerer Übersetzungsfehler in Zentimetern - je niedriger, desto besser}
}
\newglossaryentry{AUC}{
    name={AUC},
    description={Area Under Curve: Die Ergebnisse werden anhand der Genauigkeitsschwelle AUC berechnet, die von ADD gemessen wird, das einen exakten Modellabgleich durchführt, und ADD-S, das für die Bewertung symmetrischer Objekte konzipiert ist.}
}

\title{Proseminar Objektposenschätzung}
\author{Robert Jeutter}
\date{\today}
\pdfinfo{
    /Title (Proseminar Objektposenschätzung)
    /Creator (TeX)
    /Producer (pdfTeX 1.40.0)
    /Author (Robert Jeutter)
    /Subject (Deeplearning, Robotische Manipulation)
}

\begin{document}
\maketitle

\begin{multicols*}{2}
    \textbf{
        Damit ein Roboter einen Gegenstand greifen kann, ist es meist notwendig die genaue Lage des Objektes zu kennen. Dies kann sowohl über klassische Verfahren als auch über Deep-Learning-Verfahren erreicht werden. Ziel dieses Seminars ist es den Stand der Technik für die Objektposenschätzung aufzuarbeiten und vorzustellen. Der Fokus sollte dabei auf Verfahren liegen, bei denen zuvor kein Objektmodell benötig wird, sodass auch die Lage von unbekannten Objekten geschätzt werden kann.
    }

    \section{Motivation}
    %Die Schätzung der 6D-Position bekannter Objekte ist wichtig für die Interaktion von Robotern mit der realen Welt. 
    Die Erkennung von Objekten und die Schätzung ihrer Lage in 3D hat eine Vielzahl von Anwendungen in der Robotik. So ist beispielsweise die Erkennung der 3D-Lage und Ausrichtung von Objekten wichtig für die Robotermanipulation. Sie ist auch bei Aufgaben der Mensch-Roboter-Interaktion nützlich, z. B. beim Lernen aus Demonstrationen.
    %Für Robotermanipulation sind häufig Informationen über die Position des manipulierten Objekts erforderlich. 
    %In einigen Fällen kann dies durch Vorwärtskinematik erreicht werden, wobei angenommen wird, dass die Bewegung des Objekts der Bewegung des Endeffektors entspricht. Häufig reicht die Vorwärtskinematik jedoch nicht aus, um die Lage des Objekts genau zu bestimmen. Dies kann durch Schlupf beim Greifen oder bei der Manipulation mit der Hand, bei der Übergabe oder durch die Nachgiebigkeit eines Saugnapfes bedingt sein. In diesen Fällen ist eine dynamische Schätzung der Objektposition aus visuellen Daten wünschenswert.

    %Methoden zur 6D-Positionsschätzung aus Einzelbildern wurden ausgiebig untersucht. Einige von ihnen sind schnell und können die Pose für jedes neue Bild von Grund auf neu schätzen. Dies ist jedoch redundant, weniger effizient und führt zu weniger kohärenten Schätzungen für aufeinanderfolgende Bilder. Andererseits kann die Verfolgung von 6D-Objektposen über Bildsequenzen bei einer anfänglichen Posenschätzung die Schätzgeschwindigkeit verbessern und gleichzeitig kohärente und genaue Posen liefern, indem die zeitliche Konsistenz genutzt wird.
    Traditionell wird das Problem der Objektposenschätzung durch den Abgleich von Merkmalspunkten zwischen 3D-Modellen und Bildern angegangen. Diese Methoden setzen jedoch voraus, dass die Objekte reichhaltig texturiert sind, um Merkmalspunkte für den Abgleich zu erkennen. Daher sind sie nicht in der Lage, mit Objekten ohne Textur umzugehen. %Bei merkmalsbasierten Methoden werden lokale Merkmale entweder aus Points of Interest oder aus jedem Pixel des Bildes extrahiert und mit den Merkmalen der 3D-Modelle abgeglichen, um 2D-3D-Korrespondenzen herzustellen, aus denen 6D-Posen wiederhergestellt werden können. Merkmalsbasierte Methoden sind in der Lage, mit Verdeckungen zwischen Objekten umzugehen. Sie benötigen jedoch ausreichende Texturen auf den Objekten, um die lokalen Merkmale berechnen zu können. Um mit texturlosen Objekten umzugehen, wurden mehrere Methoden vorgeschlagen, um Merkmalsdeskriptoren mit Hilfe von maschinellen Lernverfahren zu lernen. Einige Ansätze wurden vorgeschlagen, um direkt auf die 3D-Objektkoordinaten jedes Pixels zu regressieren, um die 2D-3D-Korrespondenzen herzustellen. Die 3D-Koordinatenregression stößt jedoch bei symmetrischen Objekten auf Mehrdeutigkeiten.
    Die meisten bestehenden Ansätze zur Objektposenschätzung setzen den Zugriff auf das 3D-Modell einer Objektinstanz voraus. Der Zugang zu solchen 3D-Modellen erschwert die Verallgemeinerung auf neue, unbekannte Instanzen. %Um diese Einschränkung zu überwinden, haben neuere Ansätze diese Annahme gelockert und benötigen nur 3D-Modelle auf Kategorieebene für die 6D-Positionsschätzung. Dies wird häufig durch Training mit einer großen Anzahl von CAD-Modellen derselben Kategorie erreicht. Obwohl für bereits bekannte Objektkategorien vielversprechende Ergebnisse erzielt wurden, gibt es immer noch Einschränkungen z.B. durch die gerine Vielfalt von Kategorien. Beliebte 3D-Modelldatenbanken wie ShapeNet\footnote{\href{https://shapenet.org/}{shapenet.org}} und ModelNet40\footnote{\href{https://modelnet.cs.princeton.edu/}{modelnet.cs.princeton.edu}} enthalten 55 bzw. 40 Kategorien. Dies reicht bei weitem nicht aus, um die verschiedenen Objektkategorien in der realen Welt abzudecken. 
    Darüber hinaus erfordern 3D-Modelldatenbanken oft einen nicht unerheblichen manuellen Aufwand und Expertenwissen, um sie zu erstellen, wobei Schritte wie Scannen, Netzverfeinerung oder CAD-Design erforderlich sind.
    Unordnung und Verdeckungen zwischen den Objekten senken die korrekte Erkennung bei modellbasierten Verfahren zudem deutlich.
    Bei schablonenbasierten Methoden wird eine starre Schablone konstruiert und verwendet, um verschiedene Stellen im Eingabebild zu scannen. An jeder Stelle wird ein Ähnlichkeitswert berechnet, und die beste Übereinstimmung wird durch den Vergleich dieser Ähnlichkeitswerte ermittelt.
    Schablonenbasierte Methoden sind nützlich für die Erkennung texturloser Objekte. Sie können jedoch nicht sehr gut mit Verdeckungen zwischen Objekten umgehen, da die Vorlage einen niedrigen Ähnlichkeitswert hat, wenn das Objekt verdeckt ist.
    Alternativ dazu können Methoden, die eine Regression von Bildpixeln auf 3D-Objektkoordinaten erlernen, um 2D-3D-Korrespondenzen für die 6D-Positionsschätzung herzustellen, nicht mit symmetrischen Objekten umgehen.
    Außerdem können bei der Verfolgung durch solche dynamische on-the-fly Rekonstruktion von Objekten Fehler entstehen, wenn Beobachtungen mit fehlerhaften Posenschätzungen in das globale Modell einfließen. Diese Fehler wirken sich nachteilig auf die Modellverfolgung in nachfolgenden Bildern aus.

    \section{Kategorisierung}
    Motiviert durch die oben genannten Einschränkungen, zielt diese Arbeit auf eine genaue, robuste 6D-Objekterkennung ab, die auf neuartige Objekte ohne 3D-Modelle verallgemeinert werden kann.
    Die Kategorisierung aller Verfahren erfolgt nach folgendem Schemata
    \begin{description*}
        \item[Modell] Müssen für das Training oder Nutzung merkmalsbasierte oder Objektmodelle (2D, 3D, CAD) vorhanden sein?
        \item[Video-Input] Verarbeitet das Verfahren 2D Bilder, 3D Bilder mit Tiefenwahrnehmung?
        \item[Datensatz] mit welchen Datensätzen wurde das Verfahren trainiert oder getestet?
        \item[Genauigkeit] Wie akkurat ist die Objektposenschätzung im Vergleich?
        \item[Ressourcen] Wie Ressourcenintensiv ist das Verfahren? Wird spezielle Hardware benötigt?
        \item[Laufzeit] Mit welcher Geschwindigkeit ist die Verarbeitung von Eingabedaten möglich und stabil?
    \end{description*}

    \section{Verschiedene Verfahren}
    \subsection{BundleTrack}
    BundleTrack\cite{BundleTrack} ist ein Framework für die 6D-Positionsverfolgung neuartiger Objekte, das nicht von 3D-Modellen auf Instanz- oder Kategorieebene abhängt. Es nutzt komplementären Eigenschaften für die Segmentierung und robuste Merkmalsextraktion sowie die speichererweiterte Pose-Graph-Optimierung für die räumlich-zeitliche Konsistenz. Dies ermöglicht eine langfristige, abdriftarme Verfolgung in verschiedenen anspruchsvollen Szenarien, einschließlich erheblicher Verdeckungen und Objektbewegungen.

    Im Vergleich zu modernen Methoden, die auf einem CAD-Modell der Objektinstanz basieren, wird eine vergleichbare Leistung erzielt, obwohl die vorgeschlagene Methode weniger Informationen benötigt. Eine effiziente Implementierung in CUDA ermöglicht eine Echtzeitleistung von 10 Hz für das gesamte System.
    Der Code ist verfügbar unter: \href{https://github.com/wenbowen123/BundleTrack}{github.com/wenbowen123/BundleTrack}

    \begin{description*}
        \item[Modell] ohne Modelle
        \item[Video-Input] RGB-D
        \item[Datensatz] \Gls{NOCS}, \Gls{YCBInEOAT}, Davis\cite{Davis}, Youtube-VOS\cite{Youtube-vos}
        \item[Genauigkeit] kann mit Verdeckung und Objektbewegung gut umgehen. Vergleichbare Leistung mit Methoden mit CAD Modell. Im \Gls{NOCS}-Datensatz:
        \begin{itemize*}
            \item $87,4\%$ \Gls{55cm}
            \item $99,9\%$ \Gls{IoU25}
            \item $R_{err}=2,4$
            \item $T_{err}=2,1$
        \end{itemize*}
        Ergebnisse aus \Gls{AUC} Messung
        \begin{itemize*}
            \item ADD $87,34\%$
            \item ADD-S $92,53\%$
        \end{itemize*}
        \item[Ressourcen] effiziente CUDA-Implementierung, ermöglicht es, das rechenintensive Multi-Pair-Feature-Matching sowie die Pose-Graph-Optimierung für die 6D-Objekt-Positionsverfolgung online auszuführen. Alle Experimente wurden auf einem Standard-Desktop mit Intel Xeon(R) E5-1660 v3@3.00GHz Prozessor und einer einzelnen NVIDIA RTX 2080 Ti GPU durchgeführt.
        \item[Laufzeit] in CUDA Echtzeit mit 10 Hz
    \end{description*}

    \columnbreak
    \subsection{DeepIM}
    DeepIM\cite{Deepim} basiert auf einem tiefen neuronalen Netzwerk für iterative 6D-Positionsanpassung. Ausgehend von einer anfänglichen 6D-Positionsschätzung eines Objekts in einem Testbild, sagt DeepIM eine relative SE(3)-Transformation voraus, die eine gerenderte Ansicht des Objekts mit dem beobachteten Bild abgleicht.  Bei einer anfänglichen Posenschätzung ist das Netzwerk in der Lage, die Pose iterativ zu verfeinern, indem es das gerenderte Bild mit dem beobachteten Bild abgleicht. Durch die iterative Neudarstellung des Objekts auf der Grundlage der verbesserten Posenschätzungen werden die beiden Eingangsbilder des Netzes immer ähnlicher, wodurch das Netz immer genauere Posenschätzungen erzeugen kann.
    Das Netzwerk wird so trainiert, dass es eine relative Pose-Transformation vorhersagen kann, indem es eine unverzerrte Darstellung der 3D-Position und 3D-Orientierung und einen iterativen Trainingsprozess verwendet.
    \begin{description*}
        \item[Modell] 3D-CAD-Modell
        \item[Video-Input] RGB
        \item[Datensatz] \Gls{Linemod}, \Gls{Occlusion}
        \item[Genauigkeit] \Gls{Linemod}
        \begin{itemize*}
            \item $85,2\%$ \Gls{55cm}
            \item $88,6\%$ \Gls{6dpose}
            \item $97,5\&$ \Gls{2dproj}
        \end{itemize*}
        \item[Ressourcen] NVIDIA 1080 Ti GPU mit 2 Iterationen während der Tests
        \item[Laufzeit] 12fps
    \end{description*}

    \subsection{MaskFusion}
    MaskFusion\cite{MaskFusion} ist ein objektbewusstes, semantisches und dynamisches RGB-D SLAM-System in Echtzeit, das über traditionelle Systeme hinausgeht, die eine rein geometrische Karte einer statischen Szene ausgeben. MaskFusion erkennt, segmentiert und ordnet verschiedenen Objekten in der Szene semantische Klassenlabels zu, während es sie verfolgt und rekonstruiert, selbst wenn sie sich unabhängig von der Kamera bewegen.
    Während eine RGB-D-Kamera eine unübersichtliche Szene abtastet, erzeugt die bildbasierte semantische Segmentierung auf Instanzebene semantische Objektmasken, die eine Objekterkennung in Echtzeit und die Erstellung einer Darstellung auf Objektebene für die Weltkarte ermöglichen. Im Gegensatz zu früheren, auf Erkennung basierenden SLAM-Systemen benötigt MaskFusion keine bekannten Modelle der Objekte, die es erkennen kann, und kann mit mehreren unabhängigen Bewegungen umgehen. MaskFusion nutzt die Vorteile der semantischen Segmentierung auf Instanzebene, um semantische Beschriftungen in eine objektbezogene Karte zu integrieren, im Gegensatz zu neueren semantischen SLAM-Systemen, die eine semantische Segmentierung auf Voxel-Ebene durchführen.

    MaskFusion ermöglicht dichtes dynamisches RGBD-SLAM in Echtzeit auf Ebene von Objekten. Im Wesentlichen ist MaskFusion ein Multi-Modell-SLAM System, das für jedes Objekt, das es in der Szene erkennt, eine 3D-Darstellung verwaltet das es in der Szene erkennt (zusätzlich zum Hintergrundmodell). Jedes Modell wird unabhängig verfolgt und fusioniert.

    Was die Erkennung betrifft, so kann MaskFusion nur Objekte aus Klassen erkennen, auf die die MaskRCNN trainiert wurde (derzeit die 80 Klassen des \Gls{mscoco}-Datensatzes) und berücksichtigt keine Fehlklassifizierung von Objektbeschriftungen.

    \begin{description*}
        \item[Modell] mit Modell
        \item[Video-Input] RGB-D
        \item[Datensatz] \Gls{mscoco}
        \item[Genauigkeit] \Gls{NOCS}
        \begin{itemize*}
            \item $26,5\%$ \Gls{55cm}
            \item $64,9\%$ \Gls{IoU25}
            \item $28,5$ \Gls{Rerr}
            \item $8,3$ \Gls{Terr}
        \end{itemize*}
        Ergebnisse aus \Gls{AUC} Messung
        \begin{itemize*}
            \item ADD $35,07\%$
            \item ADD-S $41,88\%$
        \end{itemize*}
        \item[Ressourcen] Die Faltungsmaskierung läuft asynchron zum Rest von MaskFusion und erfordert eine spezielle GPU. Sie arbeitet mit 5Hz, und da sie den Grafikprozessor über lange Zeiträume blockiert, wird  ein anderen Grafikprozessor für die SLAM-Pipeline verwendet, der mit $>30$Hz arbeitet, wenn ein einzelnes Modell verfolgt wird. Bei Vorhandensein mehrerer nicht-statischer Objekten sinkt die Leistung und führt zu einer Bildwiederholrate von 20 Hz für 3 Modelle. Das Testsystem ist mit zwei Nvidia GTX Titan X und einem Intel Core i7, 3.5GHz auzsgestattet.
        \item[Laufzeit] $20-30$Hz
    \end{description*}

    \subsection{Neural Analysis-by-Synthesis}
    Der neuronale Analyse-durch-Synthese-Ansatz \cite{CategoryLevelObject} ist zur Schätzung der Objektposition auf Kategorieebene.
    %Sie kombinieren ein gradientenbasiertes Anpassungsverfahren mit einem parametrischen neuronalen Bildsynthesemodell, das in der Lage ist, implizit das Aussehen, die Form und die Pose ganzer Objektkategorien darzustellen, so dass zur Testzeit keine instanzspezifischen 3D-CAD-Modelle benötigt werden. 
    Durch den Einsatz eines gelernten Bildsynthesemoduls ist dieser Ansatz in der Lage, die 3D-Pose eines Objekts aus einem einzigen RGB- oder RGB-D-Bild zu ermitteln, ohne dass ein Zugriff auf instanzspezifische 3D-CAD-Modelle erforderlich ist.
    Der Kerngedanke der Analyse durch Synthese besteht darin, ein Vorwärtsmodell (z.B. eine Grafikpipeline) zu nutzen, um verschiedene Bilder zu erzeugen, die möglichen geometrischen und semantischen Zuständen der Umgebung entsprechen. Anschließend wird der Kandidat ausgewählt, der am besten mit der gemessenen visuellen Evidenz übereinstimmt.

    Zunächst wird ein Pose-Aware-Bildgenerator mit Multi-View-Bildern von synthetischen Objekten aus dem ShapeNet-Datensatz trainiert, der in der Lage ist, Objektbilder zu erzeugen, die die Pose und Erscheinung des Eingabeobjekts genau wiedergeben. Zum Zeitpunkt der Inferenz mit einem segmentierten Bild als Eingabe schätzt die Methode die Objektpose durch iterative Optimierung der Objektpose und -form, um die Diskrepanz zwischen dem Eingabebild und dem synthetisierten Bild zu minimieren.

    Der Schwerpunkt liegt auf starren Objekten.
    \begin{description*}
        \item[Modell] ohne
        \item[Video-Input] RBG und RGB-D
        \item[Datensatz] ohne
        \item[Genauigkeit] \Gls{NOCS}
        \begin{itemize*}
            \item ~95\% average translation precision
            \item ~90\% average orientation precision
        \end{itemize*}
        \item[Ressourcen]
        \item[Laufzeit]
    \end{description*}

    \subsection{6-PACK}
    6-PACK\cite{6pack} ist ein auf Bildverarbeitung basierender 6D-Posen Anker-basierter Kategorie-Level Keypoint Tracker. Dieser verfolgt einen kleinen Satz von Keypoints in RGB-D-Videos und schätzt die Objektpose durch Akkumulation der relativen Poseänderungen über die Zeit. Diese Methode erfordert kein bekanntes 3D-Modell. Stattdessen umgeht es die Notwendigkeit der Definition und Schätzung der absoluten 6D-Pose durch einen neuartigen Ankermechanismus, der der Vorschlagsmethodik für die 2D-Objekterkennung entspricht. Diese Anker bieten eine Grundlage für die Erzeugung von 3D-Keypoints.
    Im Gegensatz zu früheren Methoden, die manuelle Keypoint-Anmerkungen erfordern, wird ein unüberwachten Lernansatz eingesetzt, der die optimale Menge an 3D-Keypoints für die Verfolgung ermittelt. Diese Keypoints dienen als kompakte Repräsentation des Objekts, aus der der Pose-Unterschied zwischen zwei benachbarten Frames effizient geschätzt werden kann. Diese Keypoint-basierte Darstellung führt zu einer robusten und Echtzeit-6D-Positionsverfolgung.
    Darüber hinaus wurde 6-PACK auf einer HSR-Roboterplattform eingesetzt und gezeigt, dass die Methode Echtzeit-Tracking und Roboter-Interaktion ermöglicht.

    \begin{description*}
        \item[Modell] Kategorie-bezogene 3D Modellen
        \item[Video-Input] RGB-D
        \item[Datensatz] \Gls{NOCS}, \Gls{ShapeNetCore}
        \item[Genauigkeit] \Gls{NOCS}
        \begin{itemize*}
            \item $33,3\%$ \Gls{55cm}
            \item $94,2\%$ \Gls{IoU25}
            \item $16,0$ \Gls{Rerr}
            \item $3,5$ \Gls{Terr}
        \end{itemize*}
        \item[Ressourcen] getestet mit NVIDIA GTX1070 GPU und Intel Core i7-6700K CPU, verfolgt Posen mit 10 Hz mit weniger als 30\% des GPU-Speicherplatzes (etwa 2 GB)
        \item[Laufzeit] $>10$fps real-time interaction
    \end{description*}

    \subsection{PoseCNN}
    Ein neues \Gls{cnn} für die 6D-Objektposenschätzung. PoseCNN\cite{PoseCNN} entkoppelt die Schätzung von 3D-Rotation und 3D-Translation. Es schätzt die 3D-Verschiebung eines Objekts, indem es sein Zentrum im Bild lokalisiert und seinen Abstand zur Kamera vorhersagt. Durch Regression jedes Pixels auf einen Einheitsvektor in Richtung des Objektzentrums kann das Zentrum unabhängig vom Maßstab robust geschätzt werden. Noch wichtiger ist, dass die Pixel das Objektzentrum auch dann wählen, wenn es von anderen Objekten verdeckt wird.
    Die 3D-Rotation des Objekts wird durch Regression auf eine \Gls{quaternion}-Darstellung  geschätzt. Es werden zwei neue Verlustfunktionen für die Rotationsschätzung eingeführt, wobei der ShapeMatch-Verlust für symmetrische Objekte entwickelt wurde.
    Dadurch ist PoseCNN in der Lage, Okklusion und symmetrische Objekte in unübersichtlichen Szenen zu verarbeiten. Dies eröffnet den Weg zur Verwendung von Kameras mit einer Auflösung und einem Sichtfeld, die weit über die derzeit verwendeten Tiefenkamerasysteme hinausgehen.
    Manchmal führt SLOSS zu lokalen Minimums im Pose-Raum führt, ähnlich wie ICP\cite{ICP}.

    Die Methode erreicht Ende-zu-Ende 6D Posenschätzung und ist sehr robust gegenüber Verdeckungen zwischen Objekten.
    \begin{description*}
        \item[Modell] ohne
        \item[Video-Input] RGB, RGB-D
        \item[Datensatz] \Gls{ycb}, \Gls{Linemod}, \Gls{Occlusion}
        \item[Genauigkeit] Ergebnisse aus \Gls{AUC} Messung bei RGB
        \begin{itemize*}
            \item ADD $53,7\%$
            \item ADD-S $75,9\%$
        \end{itemize*}
        Ergebnisse aus \Gls{AUC} Messung bei RGB-D mit ICP
        \begin{itemize*}
            \item ADD $79,3\%$
            \item ADD-S $93,0\%$
        \end{itemize*}
        Ergebnisse aus \Gls{Occlusion}
        \begin{itemize*}
            \item PoseCNN Color $24,9\%$
            \item PoseCNN+ICP $78,0\%$
        \end{itemize*}
        \item[Ressourcen]
        \item[Laufzeit]
    \end{description*}

    \subsection{Robust Gaussian Filter}
    Modellbasierte 3D-Verfolgung von Objekten bei dichten Tiefenbildern als Eingabe mithilfe Robuster Gauss Filter\cite{GaussianFilter}.
    Zwei Schwierigkeiten schließen die Anwendung eines Standard-Gauß-Filters auf dieses Problem aus. Tiefensensoren sind von Messrauschen gekennzeichnet und werden durch eine Robustifizierungsmethode für Gaußfilter behoben. Dadurch wird eine heuristische Ausreißer-Erkennungsmethode verwendet, die einfache Messungen ablehnt, wenn sie nicht mit dem Modell übereinstimmen.
    Daneben sind die Rechenkosten des Standard-Gauß-Filters aufgrund der hochdimensionalen Messung unerschwinglich. Um dieses Problem zu lösen wird eine Annäherung verwendet um die Rechenkomplexität des Filters zu reduzieren.
    In quantitativen Experimenten mit realen Daten wurde gezeigt, dass diese Methode besser abschneidet als der Standard-Gauß-Filter. Außerdem mit einer auf Partikelfiltern basierenden Verfolgungsmethode bei vergleichbarer Recheneffizienz eine verbesserte Genauigkeit und Glattheit der Schätzungen erzielt.
    Die Methode zur Verfolgung der 6-Grad Freiheitsgrades und der Geschwindigkeit eines Objekts mit Tiefenmessungen nutzt eine Standard-Tiefenkamera. Der vorgeschlagene Algorithmus läuft mit der Bildrate der Kamera von 30 Hz auf nur einem CPU-Kern.

    \begin{description*}
        \item[Modell] CAD-Modell
        \item[Video-Input] RGB-D
        \item[Datensatz] \Gls{bot}
        \item[Genauigkeit]
        \begin{itemize*}
            \item Verschiebungsfehler Mittelwert $0,03008$[mm]
            \item Verschiebungsfehler Median $0,00489$[mm]
            \item Winkelfehler Mittelwert $0,39644$[Grad]
            \item Winkelfehler Median $0,06076$[Grad]
        \end{itemize*}
        \item[Ressourcen] 640×480 Pixel auf einem CPU-Kern
        \item[Laufzeit] 30Hz
    \end{description*}

    \subsection{Teaser}
    Teaser\cite{Teaser++} ist ein Algorithmus für die Registrierung von zwei 3D-Punktesätzen bei Vorhandensein einer großen Anzahl von Ausreißerkorrespondenzen.
    Zunächst wird ein neues Registrierungsproblem formuliert, indem die Kosten der abgeschnittenen kleinsten Quadrate (TLS) verwendet werden, die die Schätzung unempfindlich gegenüber einem großen Anteil von falschen Korrespondenzen macht.
    Anschließend entkoppelt ein allgemeiner graphentheoretischer Rahmen Skalen-, Rotations- und Translationsschätzungen, der eine Kaskade für die drei Transformationen lösen. Während jedes Teilproblem (Skalen-, Rotations- und Translationsabschätzung) nicht-konvex und kombinatorisch ist,
    (i) kann die TLS-Skalierung und Translationsschätzung in polynomialer Zeit über ein adaptives Abstimmungsverfahren gelöst werden,
    (ii) die TLS-Rotationsschätzung kann zu einem semidefiniten Programm umgewandelt werden und ist selbst bei extremen Ausreißerquoten robust, und
    (iii) der graphentheoretische Rahmen ermöglicht eine drastische Reduzierung von Ausreißern durch die Suche nach der maximalen Clique.
    Der Algorithmus wird TEASER (Truncated least squares Estimation And SEmidefinite Relaxation) genannt.

    TEASER ist in MATLAB implementiert, verwendet cvx\cite{cvx}, um die konvexe Relaxation zu lösen, und nutzt den Algorithmus \cite{Mosek}, um die maximalen Kluster im beschnittenen TIM-Graphen zu finden. TEASER++ ist die schnelle implementierung des TEASER Algorithmus in C++. TEASER++ folgt dem gleichen entkoppelten Ansatz, die einzige Ausnahme ist, dass die abgestufte Nicht-Konvexität verwendet wird, um das Rotations-Teilproblem zu lösen und das Douglas- Rachford-Splitting genutzt wird, um die globale Optimalität effizient zu zertifizieren.

    Der Algorithmus wurde mit zwei state-of-the-art Techniken GORE\cite{gore} und FGR\cite{fgr} verglichen.

    \begin{description*}
        \item[Modell] ohne
        \item[Video-Input] RGB-D
        \item[Datensatz] \Gls{stanford}
        \item[Genauigkeit]
        \begin{itemize*}
            \item Korrekte Registierung $91,69$ [\%]
            \item Rotationsfehler $0,066$ [Grad]
            \item Translationsfehler $0,069$ [m]
            \item Anzahl an FPFH\cite{fpfh} Korrespondenzen $525$
            \item FPFH Ausreißerquote $6,53$ [\%]
        \end{itemize*}
        \item[Ressourcen] Alle Tests wurden auf einem Laptop mit einer i7-8850H CPU und 32GB RAM durchgeführt
        \item[Laufzeit] durchschnittlich $0,059$[s]
    \end{description*}

    \subsection{se(3)-TrackNet}
    se(3)-TrackNet\cite{se-TrackNet} ist ein datengesteuerter Optimierungsansatz für die langfristige 6D-Positionsverfolgung. Er zielt darauf ab die optimale relative Pose zu identifizieren, die sich aus der aktuellen RGB-D Beobachtung und eines synthetischen Bildes, das auf der vorherigen besten Schätzung und dem Modell des Objekts beruht, bildet. Der wichtigste Beitrag ist hierbei eine neuronale Netzarchitektur, die die Merkmalskodierung in geeigneter Weise entflechtet, um die Domänenverschiebung zu reduzieren, und eine effektive 3D-Orientierungsdarstellung mittels Lie-Algebra erstellt. Folglich kann das Netzwerk, auch wenn es nur mit synthetischen Daten trainiert wird, effektiv mit realen Bildern arbeiten.
    Umfassende Experimente mit Benchmarks - bestehenden als auch einen neuen Datensatz mit signifikanten Verdeckungen im Zusammenhang mit Objektmanipulation - zeigen, dass der vorgeschlagene Ansatz durchgängig robuste Schätzungen erzielt und Alternativen übertrifft, auch wenn obwohl diese mit echten Bildern trainiert wurden.
    Die Pipeline zur Erzeugung synthetischer Daten ist in Blender\footnote{\href{https://www.blender.org/}{https://www.blender.org/}} implementiert. Um Bilder zu rendern, wird die Kameraposition zufällig einer Kugel mit einem Radius zwischen $0,6$ und $1,3$m zufällig abgetastet, gefolgt von einer zusätzlichen Drehung entlang der z-Achse der Kamera, die zwischen zwischen $0$ und $360$ Grad.
    se(3)-TrackNet erweist sich als robust gegenüber großen Verdeckungen und plötzlichen Neuorientierungen im Datensatz, die eine Herausforderung für konkurrierende Ansätze darstellen. Trotz dieser wünschenswerten Eigenschaften des vorgeschlagenen Netzwerks besteht eine Einschränkung darin, dass ein CAD-Objektmodell erforderlich ist.

    Der Ansatz rechnerisch sehr effizientest und erreicht eine Verfolgungsfrequenz von 90,9 Hz.

    \begin{description*}
        \item[Modell] synthetische CAD Modelle
        \item[Video-Input] RGB-D
        \item[Datensatz] \Gls{ycb}, \Gls{YCBInEOAT}
        \item[Genauigkeit] Ergebnisse aus \Gls{AUC} Messung
        \begin{itemize*}
            \item ADD $92,66\%$
            \item ADD-S $95,33\%$
        \end{itemize*}
        \item[Ressourcen] Experimente auf Desktop mit Intel Xeon(R) E5-1660 v3@3.00GHz CPU. Training auf einer NVIDIA RTX 2080 Ti GPU bzw. NVIDIA Tesla K40c GPU
        \item[Laufzeit] $90,9$Hz
    \end{description*}

    \subsection{dbotPF}

    \begin{description*}
        \item[Modell]
        \item[Video-Input]
        \item[Datensatz]
        \item[Genauigkeit]
        \begin{itemize*}
            \item
        \end{itemize*}
        \item[Ressourcen]
        \item[Laufzeit]
    \end{description*}

    \subsection{ICP}

    \begin{description*}
        \item[Modell]
        \item[Video-Input]
        \item[Datensatz]
        \item[Genauigkeit]
        \begin{itemize*}
            \item
        \end{itemize*}
        \item[Ressourcen]
        \item[Laufzeit]
    \end{description*}

    \subsection{KeypointNet}

    \begin{description*}
        \item[Modell]
        \item[Video-Input]
        \item[Datensatz]
        \item[Genauigkeit]
        \begin{itemize*}
            \item
        \end{itemize*}
        \item[Ressourcen]
        \item[Laufzeit]
    \end{description*}

    \subsection{NOCS}

    \begin{description*}
        \item[Modell]
        \item[Video-Input]
        \item[Datensatz]
        \item[Genauigkeit]
        \begin{itemize*}
            \item
        \end{itemize*}
        \item[Ressourcen]
        \item[Laufzeit]
    \end{description*}


    \section{Fazit}

\end{multicols*}

\section{Vergleich verschiedener Verfahren}
Vergleich der unterschiedlichen Methoden unterscheidbar nach \colorbox{Mahogany}{Klassische}, \colorbox{YellowOrange}{RNN-basierte}, \colorbox{Cyan}{CNN-basierte}, \colorbox{OliveGreen}{GNN-basierte}
\begin{table}
    \centering
    \begin{tabular}{p{1.5cm}|l|l|l|l}
        benötigen                             & ?                                     & Farbbild                                          & Tiefenbild                                        & 3D Pointcloud                               \\\hline
        \multirow{3}{1.5cm}{3D Modell}        &                                       & Contour Matching                                  & se-TrackNet\cite{se-TrackNet}                     & Robust Gaussian Filter\cite{GaussianFilter} \\
                                              & dbotPF\cite{dbotPF}                   & DeepIM\cite{Deepim}                               &                                                   &                                             \\
                                              &                                       &                                                   &                                                   &                                             \\\hline
        \multirow{3}{1.5cm}{Kategorie Modell} & NOCS\cite{NormalizedObjectCoordiante} & Feature Matching                                  &                                                   &                                             \\
                                              & KeypointNet\cite{KeypointNet}         &                                                   & 6-PACK\cite{6pack}                                &                                             \\
                                              &                                       &                                                   &                                                   &                                             \\\hline
        \multirow{3}{1.5cm}{ohne Modell}      & ICP\cite{ICP}                         & Iterative Closest Point                           & MaskFusion\cite{MaskFusion}                       &                                             \\
                                              &                                       & Analyse-durch-Synthese \cite{CategoryLevelObject} & Analyse-durch-Synthese \cite{CategoryLevelObject} & TEASER++\cite{Teaser++}                     \\
                                              &                                       &                                                   & BundleTrack\cite{BundleTrack}                     &                                             \\
                                              &                                       & PoseCNN\cite{PoseCNN}                             & PoseCNN\cite{PoseCNN}+ICP\cite{ICP}               &                                             \\
    \end{tabular}
    \caption{Übersicht unterschiedlicher Verfahren}
    \label{ubersicht}
\end{table}

\medskip

\printglossary[title=Glossar]

\printbibliography[title=Literatur]

\end{document}